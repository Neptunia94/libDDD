This program show an exemple of the generation space states of the Game Tic-Tac-Toe based on the DDD Technology (Morpion) 

Required :
 - the Boost Library >= 1.33
 - the libDDD library

Command line :
 ./morpionv2
 
Environnement :
    hom/const ==> Define type and constant of the Morpion GAME
    hom/general_v2 ==> Define basic operation for :
        1) Build the Initial State of the SDD for Morpion GAME
        2) Build the homomorphism for
            - PlayAnyFreeCell = Play all possible hit from one player X
            - CheckIsWinner = Check if there is some winner configuration
            - CheckIsNoWinner = Check if there is no winner configuration (Negation of the previous function)
    hom/notew ==> Define the homomorphism for note into state system that current configuration is won
    hom/play ==> Homomorphism use for play one hit
    hom/winner ==> Homomorphism use for build by composition the winner configuration
    morpionv2 ==> Program Main


Question :
 
 What is the Initial DDD State ?
 For each cell in game, we create one DDD Node.
 Valuation on each arc can get three walue :
    0 : Cell played by Gamer A
    1 : Cell player by Gamer B
   -1 : Empty Cell

And the beginning DDD, we add one cell for define the state of the system, and can get 4 Values
    -1 : It is to Gamer A to play 
    -2 : It is to Gamer B to play
     0 : The current configuration have been won by player A
     1 : The current configuration have been won by player B
     
Exemple of Initial DDD for TicTacToe 3x3
STATE -|-1|> 
    0 -|-1|> 
        1 -|-1|> 
            2 -|-1|> 
                3 -|-1|> 
                    4 -|-1|> 
                        5 -|-1|> 
                            6 -|-1|> 
                                7 -|-1|> 
                                    8 -|-1|> 
                                        9 -|-1|> 
                                            TERMINAL
 
 
 How to define on configuration winner ?
 For this we use the composition homomorphism winner.
 For exemple, for a 3x3 TicTacToc :
 
  winner(A,0) & winner(A,1) & winner(A,2) :
  XXX
  ...
  ...
  
  winner(A,0) & winner(A,3) & winner(A,6) :
  X..
  X..
  X..
 
 Then for get all possible configuration game for one player,  we do the union of them
   

How to define the no winner configuration ?
For this, we use the negation of the homs checkIsWinner and get only the nowinner configuration.
The is_selector operation is define by libDDD for do that, but it must be used only for a HOMOMORPHISM SELECTOR

What do the fixpoint game ?
nextAA ==> Play all possible hit of one player (can be A or B switch the SYSTEM_STATE)
winnerA ==> Check if there is a winner configuration for player A
winnerB ==> Check if there is a winner configuration for player B
noWinner ==> Check if there is no winner
notewA ==> Note a winner a configuration for player A
notewB ==> Note a winner a configuration for player B

notewA & winnerA ==> If previous configuration have been won by player A, so we note it
notewB & winnerB ==> If previous configuration have been won by player B, so we note it
nextAA & nowinner ==> Else no winner have been detected in previous configuration, so we play another hit for the player designed into STATE_SYSTEM

Now The fixpoint is the union of all of theirs wiht ID.

( [ (notewA & winnerA) + (notewB & winnerB) + (nextAA & nowinner) ] + ID)* 


 


Descritpion about Homomorphism :

---- notew ----
Used only for note a winner into the Initial Variable DDD System State
ALGO :
Terminal ==> Error
PHI(vr,vl)(the_winner)
    If vr == SYSTEM_STATE
        return vr -|the_winner|-> ID
        
---- play ----
Used only for play one gamer (PA or PB).
Rules are :
    - One user can play only if it is his state to play
    - One user can play only if there is no current winner
    - One user can take only a empty cell
ALGO :
Terminal ==> Error
PHI(vr,vl)(the_cell,the_player)
    If vr == SYSTEM_STATE
        If vl == TO_PA && the_player == PA (It is to gamer A to play)
            return vr -|TO_PB|-> Propagation_to_next(the_cell,the_player)
        If vl == TO_PB && the_player == PB (It is to gamer B to play)
            return vr -|TO_PA|-> Propagation_to_next(the_cell,the_player)
        Else
            return ZERO
            
    if vr == the_cell
        if vl == EMPTY
            return vr -|the_player|-> ID
        else
            return ZERO

---- winner ----
Used only for check if one cell have been taken by a specific gamer, and by composition, we can check
if there are some winner configuration for a specific player
ALGO :
Terminal ==> Error
PHI(vr,vl)(the_cell,the_player)
    If vr == the_cell
        If vl == the_player
            return vr -|vl|-> ID
        Else
            return ZERO
This homomorphism implements the is_selector function used for have its negation.

   

   
(**) Note :
We define the Winner possibility by :
   